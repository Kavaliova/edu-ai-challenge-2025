NewSQL (e.g., CockroachDB, Google Spanner)
âœ… Strengths:

SQL-like features with distributed scalability

Strong consistency, horizontal scaling

âš ï¸ Weaknesses:

Newer tech, not as mature or supported as classic RDBMS

Higher operational complexity

ğŸ” Fit: Good â€” combines RDBMS with scalability, but more complex to manage.

3. Trade-offs Comparison Table
Database Type	Read/Write Balance	Relationship Modeling	Scalability	Complexity	Fit Summary
Relational (e.g., PostgreSQL)	âš–ï¸ Balanced	ğŸ‘ Good (joins)	âš ï¸ Moderate	âœ… Low	Profiles/posts only
Document Store (MongoDB)	âœ… Read-optimized	âš ï¸ Weak (joins)	âœ… High	âœ… Medium	Good all-around
Wide-Column (Cassandra)	âœ… Excellent reads	âŒ Poor	âœ… Excellent	âš ï¸ High	Good for feeds, poor for relationships
Graph (Neo4j)	âš ï¸ Moderate	âœ… Excellent	âš ï¸ Moderate	âœ… Low	Best for connections
NewSQL	âœ… Balanced	ğŸ‘ Good	âœ… High	âš ï¸ High	Balanced but complex

4. Recommendation: Best-Fit Database Type
âœ… Best Fit: MongoDB (Document Store)
Why MongoDB?
Flexible Schema: Easily models user profiles and posts with varying structures.

High Read Speed: Built-in indexing and read optimization suit your 80/20 access pattern.

Horizontal Scalability: Scales well with sharding as user base grows.

Document Modeling: Supports nested documents (e.g., posts within users) for efficient reads.

Adequate Relationship Support: While not as good as a graph DB, it can handle light relationship queries via references and data duplication.

ğŸ“Œ Bonus: For complex social graphs (friends/followers), you can pair MongoDB with a graph engine like Neo4j or RedisGraph selectivelyâ€”only where necessary.

Summary
Feature	MongoDB
Scalability	âœ… Horizontal, sharded
Read performance	âœ… High, with indexing
Write performance	âœ… Good for 20% writes
Relationship support	âš ï¸ Moderate, manageable with careful modeling
Overall fit	âœ… Best compromise across all requirements
